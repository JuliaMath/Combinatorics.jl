var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Combinations","page":"API reference","title":"Combinations","text":"","category":"section"},{"location":"api/#Combinatorics.CoolLexCombinations","page":"API reference","title":"Combinatorics.CoolLexCombinations","text":"CoolLexCombinations\n\nProduce (nk)-combinations in cool-lex order.\n\nReference\n\nRuskey, F., & Williams, A. (2009). The coolest way to generate combinations. Discrete Mathematics, 309(17), 5305-5320.\n\n\n\n\n\n","category":"type"},{"location":"api/#Combinatorics.combinations-Tuple{Any, Integer}","page":"API reference","title":"Combinatorics.combinations","text":"combinations(a, n)\n\nGenerate all combinations of n elements from an indexable object a. Because the number of combinations can be very large, this function returns an iterator object. Use collect(combinations(a, n)) to get an array of all combinations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.combinations-Tuple{Any}","page":"API reference","title":"Combinatorics.combinations","text":"combinations(a)\n\nGenerate combinations of the elements of a of all orders. Chaining of order iterators is eager, but the sequence at each order is lazy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.multiset_combinations-Tuple{Any, Integer}","page":"API reference","title":"Combinatorics.multiset_combinations","text":"multiset_combinations(a, t)\n\nGenerate all combinations of size t from an array a with possibly duplicated elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.powerset","page":"API reference","title":"Combinatorics.powerset","text":"powerset(a, min=0, max=length(a))\n\nGenerate all subsets of an indexable object a including the empty set, with cardinality bounded by min and max. Because the number of subsets can be very large, this function returns an iterator object. Use collect(powerset(a, min, max)) to get an array of all subsets.\n\n\n\n\n\n","category":"function"},{"location":"api/#Combinatorics.with_replacement_combinations-Tuple{Any, Integer}","page":"API reference","title":"Combinatorics.with_replacement_combinations","text":"with_replacement_combinations(a, t)\n\nGenerate all combinations with replacement of size t from an array a.\n\n\n\n\n\n","category":"method"},{"location":"api/#Factorials","page":"API reference","title":"Factorials","text":"","category":"section"},{"location":"api/#Base.factorial-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"API reference","title":"Base.factorial","text":"factorial(n, k)\n\nCompute nk.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.derangement-Tuple{Integer}","page":"API reference","title":"Combinatorics.derangement","text":"derangement(n)\n\nCompute the number of permutations of n with no fixed points, also known as the subfactorial. An alias subfactorial for this function is provided for convenience.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.multinomial-Tuple","page":"API reference","title":"Combinatorics.multinomial","text":"multinomial(k...)\n\nCompute the multinomial coefficient binomnk_1k_2k_i = fracnk_1k_2 cdots k_i n = sumk_i. Throws an OverflowError when the input is too large.\n\nSee Also: binomial.\n\nExamples\n\njulia> # (x+y)^2 = x^2 + 2xy + y^2\n\njulia> multinomial(2, 0)\n1\n\njulia> multinomial(1, 1)\n2\n\njulia> multinomial(0, 2)\n1\n\njulia> multinomial(10, 10, 10, 10)\nERROR: OverflowError: 5550996791340 * 847660528 overflowed for type Int64\nStacktrace:\n[...]\n\nExternal links\n\nDefinitions on DLMF\nMultinomial theorem on Wikipedia\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.partialderangement-Tuple{Integer, Integer}","page":"API reference","title":"Combinatorics.partialderangement","text":"partialderangement(n, k)\n\nCompute the number of permutations of n with exactly k fixed points.\n\n\n\n\n\n","category":"method"},{"location":"api/#Multinomials","page":"API reference","title":"Multinomials","text":"","category":"section"},{"location":"api/#Combinatorics.multiexponents-Tuple{Any, Any}","page":"API reference","title":"Combinatorics.multiexponents","text":"multiexponents(m, n)\n\nReturns the exponents in the multinomial expansion (x₁ + x₂ + ... + xₘ)ⁿ.\n\nFor example, the expansion (x₁ + x₂ + x₃)² = x₁² + x₁x₂ + x₁x₃ + ... has the exponents:\n\njulia> collect(multiexponents(3, 2))\n6-element Vector{Vector{Int64}}:\n [2, 0, 0]\n [1, 1, 0]\n [1, 0, 1]\n [0, 2, 0]\n [0, 1, 1]\n [0, 0, 2]\n\n\n\n\n\n","category":"method"},{"location":"api/#Numbers","page":"API reference","title":"Numbers","text":"","category":"section"},{"location":"api/#Combinatorics.bellnum-Tuple{Integer}","page":"API reference","title":"Combinatorics.bellnum","text":"bellnum(n)\n\nCompute the nth Bell number.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.catalannum-Tuple{Integer}","page":"API reference","title":"Combinatorics.catalannum","text":"catalannum(n)\n\nCompute the nth Catalan number.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.lassallenum-Tuple{Integer}","page":"API reference","title":"Combinatorics.lassallenum","text":"lassallenum(n)\n\nCompute the nth entry in Lassalle's sequence, OEIS entry A180874.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.lobbnum-Tuple{Integer, Integer}","page":"API reference","title":"Combinatorics.lobbnum","text":"lobbnum(m,n)\n\nCompute the Lobb number L(m,n), or the generalised Catalan number given by frac2m+1m+n+1 binom2nm+n. Wikipedia : https://en.wikipedia.org/wiki/Lobb_number\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.narayana-Tuple{Integer, Integer}","page":"API reference","title":"Combinatorics.narayana","text":"narayana(n,k)\n\nCompute the Narayana number N(n,k) given by frac1nbinomnkbinomnk-1 Wikipedia : https://en.wikipedia.org/wiki/Narayana_number\n\n\n\n\n\n","category":"method"},{"location":"api/#Partitions","page":"API reference","title":"Partitions","text":"","category":"section"},{"location":"api/#Combinatorics.integer_partitions-Tuple{Integer}","page":"API reference","title":"Combinatorics.integer_partitions","text":"integer_partitions(n)\n\nList the partitions of the integer n.\n\nnote: Note\nThe order of the resulting array is consistent with that produced by the computational discrete algebra software GAP.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.partitions-Tuple{AbstractVector, Int64}","page":"API reference","title":"Combinatorics.partitions","text":"partitions(s::AbstractVector, m::Int)\n\nGenerate all set partitions of the elements of an array s into exactly m subsets, represented as arrays of arrays. Because the number of partitions can be very large, this function returns an iterator object. Use collect(partitions(s, m)) to get an array of all partitions. The number of partitions into m subsets is equal to the Stirling number of the second kind, and can be efficiently computed using length(partitions(s, m)).\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.partitions-Tuple{AbstractVector}","page":"API reference","title":"Combinatorics.partitions","text":"partitions(s::AbstractVector)\n\nGenerate all set partitions of the elements of an array s, represented as arrays of arrays. Because the number of partitions can be very large, this function returns an iterator object. Use collect(partitions(s)) to get an array of all partitions. The number of partitions to generate can be efficiently computed using length(partitions(s)).\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.partitions-Tuple{Integer, Integer}","page":"API reference","title":"Combinatorics.partitions","text":"partitions(n, m)\n\nGenerate all arrays of m integers that sum to n. Because the number of partitions can be very large, this function returns an iterator object. Use collect(partitions(n, m)) to get an array of all partitions. The number of partitions to generate can be efficiently computed using length(partitions(n, m)).\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.partitions-Tuple{Integer}","page":"API reference","title":"Combinatorics.partitions","text":"partitions(n)\n\nGenerate all integer arrays that sum to n. Because the number of partitions can be very large, this function returns an iterator object. Use collect(partitions(n)) to get an array of all partitions. The number of partitions to generate can be efficiently computed using length(partitions(n)).\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.prevprod-Tuple{Vector{Int64}, Any}","page":"API reference","title":"Combinatorics.prevprod","text":"prevprod(a::Vector{Int}, x)\n\nPrevious integer not greater than x that can be written as prod k_i^p_i for integers p_1, p_2, etc.\n\nFor integers i_1, i_2, i_3, this is equivalent to finding the largest x such that\n\ni_1^n_1 i_2^n_2 i_3^n_3 leq x\n\nfor integers n_1, n_2, n_3.\n\n\n\n\n\n","category":"method"},{"location":"api/#Permutations","page":"API reference","title":"Permutations","text":"","category":"section"},{"location":"api/#Combinatorics.levicivita-Tuple{AbstractVector{<:Integer}}","page":"API reference","title":"Combinatorics.levicivita","text":"levicivita(p)\n\nCompute the Levi-Civita symbol of a permutation p. Returns 1 if the permutation is even, -1 if it is odd, and 0 otherwise.\n\nThe parity is computed by using the fact that a permutation is odd if and only if the number of even-length cycles is odd.\n\nExamples\n\n```jldoctest julia> levicivita([1, 2, 3]) 1\n\njulia> levicivita([3, 2, 1]) -1\n\njulia> levicivita([1, 1, 1]) 0\n\njulia> levicivita(collect(1:100)) 1\n\njulia> levicivita(ones(Int, 100)) 0 ````\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.multiset_permutations-Tuple{Any, Integer}","page":"API reference","title":"Combinatorics.multiset_permutations","text":"multiset_permutations(a, t)\n\nGenerate all permutations of size t from an array a with possibly duplicated elements.\n\nExamples\n\njulia> collect(permutations([1,1,1], 2))\n6-element Vector{Vector{Int64}}:\n [1, 1]\n [1, 1]\n [1, 1]\n [1, 1]\n [1, 1]\n [1, 1]\n\njulia> collect(multiset_permutations([1,1,1], 2))\n1-element Vector{Vector{Int64}}:\n [1, 1]\n\njulia> collect(multiset_permutations([1,1,2], 3))\n3-element Vector{Vector{Int64}}:\n [1, 1, 2]\n [1, 2, 1]\n [2, 1, 1]\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.nthperm!-Tuple{AbstractVector, Integer}","page":"API reference","title":"Combinatorics.nthperm!","text":"nthperm!(a, k)\n\nIn-place version of nthperm; the array a is overwritten.\n\nExamples\n\njulia> a = [1, 2, 3];\n\njulia> collect(permutations(a))\n6-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 3, 2]\n [2, 1, 3]\n [2, 3, 1]\n [3, 1, 2]\n [3, 2, 1]\n\njulia> nthperm!(a, 3); a\n3-element Vector{Int64}:\n 2\n 1\n 3\n\njulia> nthperm!(a, 4); a\n3-element Vector{Int64}:\n 1\n 3\n 2\n\njulia> nthperm!(a, 0)\nERROR: ArgumentError: permutation k must satisfy 0 < k ≤ 6, got 0\n[...]\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.nthperm-Tuple{AbstractVector, Integer}","page":"API reference","title":"Combinatorics.nthperm","text":"nthperm(a, k)\n\nCompute the kth lexicographic permutation of the vector a.\n\nExamples\n\njulia> collect(permutations([1,2]))\n2-element Vector{Vector{Int64}}:\n [1, 2]\n [2, 1]\n\njulia> nthperm([1,2], 1)\n2-element Vector{Int64}:\n 1\n 2\n\njulia> nthperm([1,2], 2)\n2-element Vector{Int64}:\n 2\n 1\n\njulia> nthperm([1,2], 3)\nERROR: ArgumentError: permutation k must satisfy 0 < k ≤ 2, got 3\n[...]\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.nthperm-Tuple{AbstractVector{<:Integer}}","page":"API reference","title":"Combinatorics.nthperm","text":"nthperm(p)\n\nReturn the integer k that generated permutation p. Note that nthperm(nthperm([1:n], k)) == k for 1 <= k <= factorial(n).\n\nExamples\n\njulia> nthperm(nthperm([1:3...], 4))\n4\n\njulia> collect(permutations([1, 2, 3]))\n6-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 3, 2]\n [2, 1, 3]\n [2, 3, 1]\n [3, 1, 2]\n [3, 2, 1]\n\njulia> nthperm([1, 2, 3])\n1\n\njulia> nthperm([3, 2, 1])\n6\n\njulia> nthperm([1, 1, 1])\nERROR: ArgumentError: argument is not a permutation\n[...]\n\njulia> nthperm(collect(1:10))\n1\n\njulia> nthperm(collect(10:-1:1))\n3628800\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.parity-Tuple{AbstractVector{<:Integer}}","page":"API reference","title":"Combinatorics.parity","text":"parity(p)\n\nCompute the parity of a permutation p using the levicivita function, permitting calls such as iseven(parity(p)). If p is not a permutation then an error is thrown.\n\nExamples\n\njulia> parity([1, 2, 3])\n0\n\njulia> parity([3, 2, 1])\n1\n\njulia> parity([1, 1, 1])\nERROR: ArgumentError: Not a permutation\n[...]\n\njulia> parity((collect(1:100)))\n0\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.permutations-Tuple{Any, Integer}","page":"API reference","title":"Combinatorics.permutations","text":"permutations(a, t)\n\nGenerate all size t permutations of an indexable object a. Only works for a with defined length.  If (t <= 0) || (t > length(a)), then returns an empty vector of eltype of a\n\nExamples\n\njulia> [ (len, permutations(1:3, len)) for len in -1:4 ]\n6-element Vector{Tuple{Int64, Any}}:\n (-1, Vector{Int64}[])\n (0, [Int64[]])\n (1, [[1], [2], [3]])\n (2, Combinatorics.Permutations{UnitRange{Int64}}(1:3, 2))\n (3, Combinatorics.Permutations{UnitRange{Int64}}(1:3, 3))\n (4, Vector{Int64}[])\n\njulia> [ (len, collect(permutations(1:3, len))) for len in -1:4 ]\n6-element Vector{Tuple{Int64, Vector{Vector{Int64}}}}:\n (-1, [])\n (0, [[]])\n (1, [[1], [2], [3]])\n (2, [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]])\n (3, [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]])\n (4, [])\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.permutations-Tuple{Any}","page":"API reference","title":"Combinatorics.permutations","text":"permutations(a)\n\nGenerate all permutations of an indexable object a in lexicographic order. Because the number of permutations can be very large, this function returns an iterator object. Use collect(permutations(a)) to get an array of all permutations. Only works for a with defined length.\n\nExamples\n\njulia> permutations(1:2)\nCombinatorics.Permutations{UnitRange{Int64}}(1:2, 2)\n\njulia> collect(permutations(1:2))\n2-element Vector{Vector{Int64}}:\n [1, 2]\n [2, 1]\n\njulia> collect(permutations(1:3))\n6-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 3, 2]\n [2, 1, 3]\n [2, 3, 1]\n [3, 1, 2]\n [3, 2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api/#Young-diagrams","page":"API reference","title":"Young diagrams","text":"","category":"section"},{"location":"api/#Combinatorics.MN1inner-Tuple{Vector{Int64}, Dict, Partition, Integer}","page":"API reference","title":"Combinatorics.MN1inner","text":"Recursively compute the character of the partition μ using the Murnaghan-Nakayama rule.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.character-Tuple{Partition, Partition}","page":"API reference","title":"Combinatorics.character","text":"character(λ::Partition, μ::Partition)\n\nCompute the character chi^lambda(mu) of the partition μ in the λth irreducible representation (\"irrep\") of the symmetric group S_n.\n\nImplements the Murnaghan-Nakayama algorithm as described in:\n\nDan Bernstein,\n\"The computational complexity of rules for the character table of Sn\",\nJournal of Symbolic Computation, vol. 37 iss. 6 (2004), pp 727-748.\ndoi:10.1016/j.jsc.2003.11.001\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.isrimhook-Tuple{Int64, Int64}","page":"API reference","title":"Combinatorics.isrimhook","text":"isrimhook(a::Int, b::Int)\n\nTake two elements of a partition sequence, with a to the left of b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.isrimhook-Tuple{Partition, Partition}","page":"API reference","title":"Combinatorics.isrimhook","text":"isrimhook(ξ::SkewDiagram)\nisrimhook(λ::Partition, μ::Partition)\n\nCheck whether the given skew diagram is a rim hook.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.leglength-Tuple{Partition, Partition}","page":"API reference","title":"Combinatorics.leglength","text":"leglength(ξ::SkewDiagram)\nleglength(λ::Partition, μ::Partition)\n\nCompute the leg length for the given skew diagram.\n\nnote: Note\nStrictly speaking, the leg length is defined for rim hooks only, but here we define it for all skew diagrams.\n\n\n\n\n\n","category":"method"},{"location":"api/#Combinatorics.partitionsequence-Tuple{Partition}","page":"API reference","title":"Combinatorics.partitionsequence","text":"partitionsequence(lambda::Partition)\n\nCompute essential part of the partition sequence of lambda.\n\n\n\n\n\n","category":"method"},{"location":"README_old/#Combinatorics","page":"Combinatorics","title":"Combinatorics","text":"","category":"section"},{"location":"README_old/","page":"Combinatorics","title":"Combinatorics","text":"(Image: CI) (Image: Coverage Status) (Image: codecov)","category":"page"},{"location":"README_old/","page":"Combinatorics","title":"Combinatorics","text":"A combinatorics library for Julia, focusing mostly (as of now) on enumerative combinatorics and permutations.  As overflows are expected even for low values, most of the functions always return BigInt, and are marked as such below.","category":"page"},{"location":"README_old/#Installation","page":"Combinatorics","title":"Installation","text":"","category":"section"},{"location":"README_old/","page":"Combinatorics","title":"Combinatorics","text":"In the Julia REPL, type ]add Combinatorics and then using Combinatorics to access the below functions.","category":"page"},{"location":"README_old/#Usage","page":"Combinatorics","title":"Usage","text":"","category":"section"},{"location":"README_old/","page":"Combinatorics","title":"Combinatorics","text":"This library provides the following functions:","category":"page"},{"location":"README_old/","page":"Combinatorics","title":"Combinatorics","text":"bellnum(n): returns the n-th Bell number; always returns a BigInt;\ncatalannum(n): returns the n-th Catalan number; always returns a BigInt;\nlobbnum(m,n): returns the generalised Catalan number at m and n; always returns a BigInt;\nnarayana(n,k): returns the general Narayana number at any given n and k; always returns a BigInt;\ncombinations(a,n): returns all combinations of n elements of indexable object a;\ncombinations(a): returns combinations of all order by chaining calls to combinations(a,n);\nderangement(n)/subfactorial(n): returns the number of permutations of n with no fixed points; always returns a BigInt;\npartialderangement(n, k): returns the number of permutations of n with exactly k fixed points; always returns a BigInt;\ndoublefactorial(n): returns the double factorial n!!; always returns a BigInt;\nfibonaccinum(n): the n-th Fibonacci number; always returns a BigInt;\nhyperfactorial(n): the n-th hyperfactorial, i.e. prod([i^i for i = 2:n]; always returns a BigInt;\ninteger_partitions(n): returns a Vector{Int} consisting of the partitions of the number n.\njacobisymbol(a,b): returns the Jacobi symbol (a/b);\nlassallenum(n): returns the nth Lassalle number A<sub>n</sub> defined in arXiv:1009.4225 (OEIS A180874); always returns a BigInt;\nlegendresymbol(a,p): returns the Legendre symbol (a/p);\nlucasnum(n): the n-th Lucas number; always returns a BigInt;\nmultifactorial(n): returns the m-multifactorial n(!^m); always returns a BigInt;\nmultinomial(k...): receives a tuple of k_1, ..., k_n and calculates the multinomial coefficient (n k), where n = sum(k); returns a BigInt only if given a BigInt;\nmultiexponents(m,n): returns the exponents in the multinomial expansion (x₁ + x₂ + ... + xₘ)ⁿ;\nprimorial(n): returns the product of all positive prime numbers <= n; always returns a BigInt;\npowerset(a): returns all subsets of an indexable object a\nstirlings1(n, k, signed=false): returns the (n,k)-th Stirling number of the first kind; the number is signed if signed is true; returns a BigInt only if given a BigInt.\nstirlings2(n, k): returns the (n,k)-th Stirling number of the second kind; returns a BigInt only if given a BigInt.\nnthperm(a, k): Compute the kth lexicographic permutation of the vector a.\npermutations(a): Generate all permutations of an indexable object a in lexicographic order.","category":"page"},{"location":"README_old/#Young-diagrams","page":"Combinatorics","title":"Young diagrams","text":"","category":"section"},{"location":"README_old/","page":"Combinatorics","title":"Combinatorics","text":"Limited support for working with Young diagrams is provided.","category":"page"},{"location":"README_old/","page":"Combinatorics","title":"Combinatorics","text":"partitionsequence(a): computes partition sequence for an integer partition a\nx = a \\ b creates the skew diagram for partitions (tuples) a, b\nisrimhook(x): checks if skew diagram x is a rim hook\nleglength(x): computes leg length of rim hook x\ncharacter(a, b): computes character the partition b in the ath irrep of Sn","category":"page"},{"location":"#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"A combinatorics library for Julia, focusing mostly (as of now) on enumerative combinatorics and permutations. As overflows are expected even for low values, most of the functions always return BigInt, and are marked as such below.","category":"page"},{"location":"#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"In the Julia REPL, type ]add Combinatorics and then using Combinatorics to access the functions listed below.","category":"page"},{"location":"#Index","page":"Getting started","title":"Index","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"","category":"page"}]
}
